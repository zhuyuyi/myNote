### 执行上下文

执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。

1. 全局环境：JavaScript代码运行起来会首先进入该环境
2. 函数环境：当函数被调用执行时，会进入当前函数中执行代码
3. eval（不建议使用，可忽略）

栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。

``` javascript
var superProgrammer = 'bge';
function BossBge() {
    var programmer = 'zyy';
    function ypgAndZtg() {
        var goodProgrammer = programmer;
        programmer = superProgrammer;
        superProgrammer = goodProgrammer;
    }
    ypgAndZtg();
}
BossBge();
```
第一步：全局上下文入栈

第二步：全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了 BossBge() ，这一句激活函数 BossBge 创建它自己的执行上下文，因此第二步就是 BossBge 的执行上下文入栈。

第三步： BossBge 的上下文入栈之后，控制器开始执行其中的可执行代码，遇到 ypgAndZtg() 之后又激活了一个执行上下文。因此第三步是 ypgAndZtg 的执行上下文入栈。

第四步：在 ypgAndZtg 的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕， ypgAndZtg 的上下文从栈中弹出。

第五步： ypgAndZtg 的执行上下文弹出之后，继续执行 BossBge 的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，就只身下全局上下文了。

###### 总结

1. 单线程
2. 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待
3. 全局上下文只有唯一的一个，它在浏览器关闭时出栈
4. 函数的执行上下文的个数没有限制
5. 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

###### 巩固

```javascript
function f1(){
    var n=999;
    function f2(){
        alert(n);
    }
    return f2;
}
var result=f1();
result(); // 999
```
第一步：全局上下文入栈
第二步：执行流执行到 var result = f1() 时，f1 执行上下文入栈，由于 此时 f2 在 f1 中只是声明，没有调用，所以没有产生执行上下文。
第三步：f1出栈
第四步：执行流执行到 result() 时，调用了 f2 ,f2 入栈
第五步：f2 出栈，回到全局上下文
